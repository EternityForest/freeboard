<!DOCTYPE HTML>

<html>

<head>
   <script src="../lib/js/thirdparty/nacl-fast.js"></script>

   <script src="../lib/js/thirdparty/nano-sql.min.js"></script>
   <script src="../lib/js/thirdparty/nanosql.fuzzy.min.js"></script>
   <script src="../lib/js/thirdparty/blake2b.js"></script>
   <script src="../lib/js/thirdparty/structjsfork.js"></script>
   <script src="../lib/js/thirdparty/stable-stringify.js"></script>

   <script type="text/javascript">


      function arrayToBase64(buffer) {
         var binary = '';
         var bytes = [].slice.call(buffer);
         bytes.forEach((b) => binary += String.fromCharCode(b));
         return window.btoa(binary);
      };

      function base64ToArray(base64) {
         var binary_string = window.atob(base64);
         var len = binary_string.length;
         var bytes = new Uint8Array(len);
         for (var i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
         }
         return bytes
      }
      json = JSON

      function DrayerDatabaseConnection(dbname, settings) {
         self = this

         self.settings = settings

         self.connections = {}

         self.concatTypedArrays = function (a, b) { // a, b TypedArray of same type
            var c = new (a.constructor)(a.length + b.length);
            c.set(a, 0);
            c.set(b, a.length);
            return c;
         }



         self.makeDB = async function () {

            if (self.settings.perm) {
               pt = "PERM"
            }
            else {
               pt = "TEMP"
            }

            self.db = await nSQL().createDatabase({
               id: dbname,
               mode: pt, // pass in "PERM" to switch to persistent storage mode!
               tables: [
                  {
                     name: "records",
                     model:
                     {
                        "id:uuid": { pk: true },
                        "parent:uuid": {},
                        "time:int": {},
                        "arrival:int": {},
                        "type:string": {},
                        "name:string": {},
                        "title:string": {},
                        "body:string": {},
                        "description:string": {},
                        "signature:string": {}

                     },
                     indexes:
                     {
                        "arrival:int": {},
                        "parent:uuid": {},
                        "time:int": {},
                        "name:string": { search: true },
                        "type:string": {},
                        "body:string": { search: true },
                        "title:string": { search: true },
                     }
                  },
                  {
                     name: "localNodeInfo",
                     model:
                     {
                        "key:string": { pk: true },
                        "value:string": {},
                     },
                     indexes:
                     {

                     }
                  },

                  {
                     name: "syncNodes",
                     model:
                     {
                        "id:string": { pk: true },
                        "syncTime:int": {}
                     }
                  }
               ],
               plugins: [
                  FuzzySearch()
               ]
            })




            //Make sure we have a local keypair
            var localNode = await nSQL('localNodeInfo').query("select").where(['key', '=', "keypair"]).exec()
            if (localNode.length) {
               self.localPubkey = base64ToArray(localNode[0].public)
               self.localSecretKey = base64ToArray(localNode[0].public)
            }
            else {
               nSQL().useDatabase(dbname)

               var k = nacl.sign.keyPair()
               self.localPubkey = k.publicKey
               self.localSecretKey = k.secretKey

               k = {
                  "public": arrayToBase64(self.localPubkey),
                  "secret": arrayToBase64(self.localSecretKey)
               }

               await nSQL('localNodeInfo').query("upsert", [{ 'key': 'keypair', value: k }]).exec()
            }

         }


         self.dbSucess = self.makeDB()


         self.alreadySentSyncRequest = false

         //Encode a JSON into the compressed 
         self.encodeMessage = function (m) {

            m = stableStringify(m)
            m = new TextEncoder("utf-8").encode(m)

            var pw = self.settings.writePassword || self.settings.syncKey
            pw = new TextEncoder("utf-8").encode(pw)

            //No you cannot just use the tweetnacl hash. Tried that! It's not actually libsodium compatble.
            var keyhint = blake2b(pw,false,32).slice(0,16)

            var t = BigInt(Date.now() * 1000)
            var time = new Uint8Array(struct("<QQQ").pack(t, 0, 0,))

            m = nacl.secretbox(m, time, pw)

            //Don't send the padding
            var time = new Uint8Array(struct("<Q").pack(t))

            var b = self.concatTypedArrays(time, m)

            b = nacl.sign(b, self.localSecretKey)
            b = self.concatTypedArrays(self.localPubkey, b)
            b=self.concatTypedArrays(keyhint,b)
            return b
         }

         self.decodeMessage = function (m) {

            //Server to client messages never use the write password.
            var key = m.slice(0, 16)

            var publicKey = m.slice(16, 16+32)
            m = m.slice(16+32, m.length)
            m = nacl.sign.open(m, publicKey)


            var time = m.slice(0, 8)
            var timeint = struct("<Q").unpack(time.buffer)[0]
            var nonce = new Uint8Array(struct("<QQQ").pack(timeint, 0, 0,))


            //Not worth it to have a whole check beforehand, we are not going to be getting many messages with a write password,
            //it's just there for self test
            var m2 = nacl.secretbox.open(m.slice(8), nonce, new TextEncoder("utf-8").encode(self.settings.syncKey))
            if(m2==null)
            {
               m2 = nacl.secretbox.open(m.slice(8), nonce, new TextEncoder("utf-8").encode(self.settings.writePassword))
            }

            m = new TextDecoder("utf-8").decode(m2)
            m = json.parse(m)
            console.log(m)
            return [m, publicKey]
         }

         self.handleIncoming = async function (m, socket) {

            var nodeID = m[1];
            var d = m[0];
            var node = await nSQL('syncNodes').query("select").where(['id', '=', arrayToBase64(nodeID)]).exec()
               var syncTime = 0;
               if(node.length)
               {
                  syncTime=node[0].syncTime;
               }
               
            //On reconnect, we are going to send our sync request
            if (!socket.alreadySentSyncRequest) {
               socket.alreadySentSyncRequest = true

               socket.send(self.encodeMessage({"getNewArrivals": syncTime}))
            }

            //Keep track of the highest remote arrival time in our record set.
            //That is what we will later use to ask if there are any newer records.
            if(d.records && d.records.length)
            {
               for(i in d.records)
               {
                  self.insertDocument(d.records[i[0]])
                  if(d.records[i[0]].arrival>syncTime)
                  {
                     syncTime = d.records[i[0]].arrival;
                  }
               }
            
            await nSQL('syncNodes').query("upsert",[{id: arrayToBase64(nodeID),  x}])
            }

            //We don't currently deal with record signing here, and can only push  records if we have the password
            if(self.writePassword)
            {
               if(d.getNewArrivals)
               {
                  var rv = {}
                  rv.records = []
                  var r = await nSQL('records').query('select').where(['arrival','>',d.getNewArrivals])
                  for(i in r)
                  {
                     rv.records.append([r[i]])
                  }
                  socket.send(self.encodeMessage(rv))
               }
            }
         }


         self.insertDocument = async function(document)
         {

            await nSQL('records').query('delete').where(['id','=', document.id])

            //We can delete all child records for real, because if we see them again, we will know they aren't valid due to
            //the null parent
            if(document.type=='null')
            {
               await nSQL('records').query('delete').where(['parent','=',document.id])
            }

            //just 
            if(document.parent)
            {
               var x = await nSQL('records').query('select').where(['id','=',document.parent])
               if(x)
               {
                  if(x.type=='null')
                  {
                     return document.id
                  }
               }
            }
            document.arrival=Date.now()*1000
            await nSQL('records').query('insert',[document])
            return document.id
         }
         self.connect = async function (url) {

            await self.dbSucess

            alert("WebSocket is supported by your Browser!");

            // Let us open a web socket
            var ws = new WebSocket(url || "ws://localhost:7001");
            self.connections[url] = ws

            ws.onopen = function () {

               // Web Socket is connected, send data using send()
               ws.send(self.encodeMessage({}));
            };

            ws.onmessage = function (evt) {
               var received_msg = evt.data;

               evt.data.arrayBuffer().then(function (buffer) {
                  var buffer2 = new Uint8Array(buffer);
                  self.handleIncoming(self.decodeMessage(buffer2), ws);
               }).catch(
                  console.log
               )
            };

            ws.onclose = function () {
               setTimeout(10000,
                  function () {
                     if (self.connections[url]) {
                        self.connect(url)
                     }
                  })
            }
            ws.onerror = function () {
               setTimeout(10000,
                  function () {
                     if (self.connections[url]) {
                        self.connect(url)
                     }
                  })
            }
         };
      }



      db = new DrayerDatabaseConnection("poupe", { writePassword: "/ROaMEXIiZ7ehbj4usrmBhsMgoQjmusV", syncKey: "9+ArW5GIqcJUaaCkh8sA3i1GQhOQWofE", perm: false })
      db.dbSucess.then(function () {
         console.log("DB open")
         console.log(db.decodeMessage(db.encodeMessage({})))
      })

      db.connect()
      

   </script>

</head>

<body>
   <div id="sse">
      <a href="javascript:WebSocketTest()">Run WebSocket</a>
   </div>

</body>

</html>
